#version 450
#extension GL_ARB_separate_shader_objects : enable
#extension GL_EXT_scalar_block_layout : enable
#extension GL_NV_shader_subgroup_partitioned : enable

// TODO: add bindings
layout(binding = 0) buffer vA{uint aVals[];}; 

layout(binding = 1) buffer vB{uint bVals[];}; 

layout(binding = 2) buffer Lines{
	uint counts[];
};

layout(binding = 3) uniform Infos{
    uint amtOfDataPoints;
    uint aBins, bBins;
    uint padding;
};

layout (local_size_x = 256,local_size_y=1,local_size_z=1) in;

// as each element of aVals and bVals contain two float16 we have to unpack
void main(){
    float aVal = unpackHalf2x16(aVals[gl_GlobalInvocationID.x >> 1])[gl_GlobalInvocationID.x & 1];
    float bVal = unpackHalf2x16(bVals[gl_GlobalInvocationID.x >> 1])[gl_GlobalInvocationID.x & 1];
    uint binA = min(uint(fract(aVal) * float(aBins)), aBins);
    uint binB = min(uint(fract(bVal) * float(bBins)), bBins);
    //binA = uint(float(gl_GlobalInvocationID.x) / float(amtOfDataPoints) * float(aBins));
    //binB = uint(float(gl_GlobalInvocationID.x * 2) / float(amtOfDataPoints) * float(bBins)) % bBins;
    uint finalBin = binA * bBins + binB;    // linear index

    // Find subgroup ( sg ) indices with same pixelID
    uvec4 sg = subgroupPartitionNV(finalBin);
    uint count = subgroupPartitionedAddNV(1, sg);
    uint tId = subgroupPartitionedMinNV(gl_SubgroupInvocationID, sg);

    if(tId == gl_SubgroupInvocationID)
        atomicAdd(counts[finalBin], count);         // incrementing
}