#version 450
#extension GL_EXT_nonuniform_qualifier : enable
#extension GL_NV_shader_subgroup_partitioned: enable
#extension GL_KHR_shader_subgroup_vote : enable

layout(binding = 0) buffer vA{uint v[];}a[]; 

layout(binding = 2) buffer Lines{
	uint v[];
}c[];

layout(binding = 3) buffer Activations{uint activations[];};

layout(binding = 4) uniform Infos{
    uint amtOfDataPoints;
    uint aBins, bBins;      // b bins is used to determine switch of attributes (needs to be done to account for not increasingly ordered attributes)
    uint indexOffset;
    uint amtOfCounts;
    uint pa,dd,ing;
};

const uint reductionAdd = 0;
const uint reductionAddNonAtomic = 1;
const uint reductionAddPartitionNonAtomic = 2;
const uint reductionSubgroupAdd = 3;
const uint reductionSubgroupAllAdd = 4;
const uint reductionMin = 5;
const uint reductionSubgroupMin = 6;
const uint reductionMax = 7;        // currently unused
const uint reductionSubgroupMax = 8;// currently unused

layout(constant_id = 0) const uint reductionType = reductionAdd;

layout (local_size_x = 256,local_size_y=1,local_size_z=1) in;

void main(){
    if(gl_GlobalInvocationID.x >= amtOfDataPoints)
        return;
    const uint indexDiv32 = gl_GlobalInvocationID.x / 32 + indexOffset;  // index offset is already divided by 32
    uint act = activations[indexDiv32];
    if((act & (1 << (gl_GlobalInvocationID.x & 31))) == 0)
        return;
    float aVal = unpackHalf2x16(a[0].v[gl_GlobalInvocationID.x >> 1])[gl_GlobalInvocationID.x & 1];
    const float invDist = aVal;
    for(int i = 1; i <= amtOfCounts; ++i){
        float bVal = unpackHalf2x16(a[i].v[gl_GlobalInvocationID.x >> 1])[gl_GlobalInvocationID.x & 1];
        uint binA = min(uint(aVal * float(aBins)), aBins - 1);
        uint binB = min(uint(bVal * float(aBins)), aBins - 1);
        if(bool(bBins & (1 << (i - 1)))){ // switching bins if switching bit is set
            uint tmp = binA;
            binA = binB;
            binB = tmp;
        }
        uint finalBin = binA * aBins + binB;    // linear index

        //atomicAdd(c[i - 1].v[finalBin], 1);

        switch(reductionType){
        case reductionAdd:
            atomicAdd(c[i - 1].v[finalBin], 1);
            break;
        case reductionAddNonAtomic:
            c[i - 1].v[finalBin] += 1;
            break;
        case reductionAddPartitionNonAtomic:
            // Find subgroup ( sg ) indices with same pixelID
            uvec4 sg = subgroupPartitionNV(finalBin);
            uint count = subgroupPartitionedAddNV(1, sg);
            uint tId = subgroupPartitionedMinNV(gl_SubgroupInvocationID, sg);
            if(tId == gl_SubgroupInvocationID)
                c[i - 1].v[finalBin] += count;         // incrementing
            break;
        case reductionSubgroupAdd:
            // Find subgroup ( sg ) indices with same pixelID
            sg = subgroupPartitionNV(finalBin);
            count = subgroupPartitionedAddNV(1, sg);
            tId = subgroupPartitionedMinNV(gl_SubgroupInvocationID, sg);
            if(tId == gl_SubgroupInvocationID)
                atomicAdd(c[i - 1].v[finalBin], count);         // incrementing
            break;
        case reductionSubgroupAllAdd:
            if(subgroupAllEqual(finalBin) && subgroupElect())
                atomicAdd(c[i - 1].v[finalBin], gl_SubgroupSize);
            else
                atomicAdd(c[i - 1].v[finalBin], 1);
            break;
        case reductionMin:
            uint val = 20;
            if(val < c[i - 1].v[finalBin])
                atomicMin(c[i - 1].v[finalBin], val);
            break;
        case reductionSubgroupMin:
            val = 20;
            sg = subgroupPartitionNV(finalBin);
            uint m = subgroupPartitionedMinNV(val, sg);
            if(val < c[i - 1].v[finalBin] && m == val)
                atomicMin(c[i - 1].v[finalBin], val);

            break;
        case reductionMax:

            break;
        case reductionSubgroupMax:
            // hardcoding center to 1 on first axis
            val = uint(invDist * 10000);

            sg = subgroupPartitionNV(finalBin);
            m = subgroupPartitionedMaxNV(val, sg);
            if(val > c[i - 1].v[finalBin] && m == val)
                atomicMax(c[i - 1].v[finalBin], val);

            break;
        }

        aVal = bVal;
    }
}