#version 460
#extension GL_GOOGLE_include_directive : enable
#extension GL_KHR_shader_subgroup_arithmetic : enable

#include "radixHeader.glsl"

layout(local_size_x = TPB, local_size_y = 1, local_size_z = 1) in;

shared GroupInfo sharedInfo;
shared uint sharedKeys[KPB];
void main(){
    //parallel loading of the group info (exclusive add offsets for key scattering)
    if(gl_LocalInvocationID.x < NUMKEYS)
        sharedInfo.keyCount[gl_LocalInvocationID.x] = groupInfos.i[gl_WorkGroupID.x].keyCount[gl_LocalInvocationID.x];
    barrier();
    
    uint front = uniformInfo[0].pass & 1;
    uint back = front ^ 1;
    uint globalHistIndex = groupInfos.i[gl_WorkGroupID.x].globalHistIndex;
    uint blockStart = groupInfos.i[gl_WorkGroupID.x].startOffset;
    uint blockEnd = uniformInfo[front].globalHistograms[globalHistIndex].endOffset;
    const uint subgroupStorage = SUBGROUP_SIZE * KPT;
    for(int i = 0; i < KPT; ++i){
        uint index = blockStart + gl_SubgroupID * subgroupStorage + SUBGROUP_SIZE * i + gl_SubgroupInvocationID;
        uint k = keys[front].k[index];
        uint curBucket = getMaskedKey(k, uniformInfo[0].pass);
        uint offset = atomicAdd(sharedInfo.keyCount[curBucket], 1);    // adding one to the bucket as an element is inserted
        sharedKeys[offset] = k;
    }
    barrier(); // waiting for all workgroups to assign their keys to the shared key array
    //care: TPB have to be more than there are buckets!!!!
    if(gl_LocalInvocationID.x < NUMKEYS){
        uint offset = 0;
        if(gl_LocalInvocationID.x != 0) offset = sharedInfo.keyCount[gl_LocalInvocationID.x - 1];
        uint count = sharedInfo.keyCount[gl_LocalInvocationID.x] - offset;
        if(count > 0){
            uint bucketPos = atomicAdd(uniformInfo[front].globalHistograms[globalHistIndex].keyCount[gl_LocalInvocationID.x], count);
            for(int c = 0; c < count; ++c){
                keys[back].k[blockStart + bucketPos + c] = sharedKeys[offset + c];
            }
        }
    }
}