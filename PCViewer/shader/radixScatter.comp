#version 460
#extension GL_GOOGLE_include_directive : enable
#extension GL_KHR_shader_subgroup_arithmetic : enable

#include "radixHeader.glsl"

layout(local_size_x = TPB, local_size_y = 1, local_size_z = 1) in;

shared GroupInfo sharedInfo;
shared uint sharedKeys[KPB];
void main(){
    //parallel loading of the group info (exclusive add offsets for key scattering)
    if(gl_LocalInvocationID.x < NUMKEYS)
        sharedInfo.keyCount[gl_LocalInvocationID.x] = groupInfos.i[gl_WorkGroupID.x].keyCount[gl_LocalInvocationID.x];
    barrier();
    
    uint front = uniformInfo[0].pass & 1;
    uint back = front ^ 1;
    uint globalHistIndex = groupInfos.i[gl_WorkGroupID.x].globalHistIndex;
    uint blockStart = groupInfos.i[gl_WorkGroupID.x].startOffset;
    uint globalStart = uniformInfo[front].globalHistograms[globalHistIndex].startOffset;
    uint blockEnd = uniformInfo[front].globalHistograms[globalHistIndex].endOffset;
    uint maxElem = blockEnd - blockStart;
    const uint subgroupStorage = SUBGROUP_SIZE * KPT;
    for(int i = 0; i < KPT; ++i){
        uint index = blockStart + gl_SubgroupID * subgroupStorage + SUBGROUP_SIZE * i + gl_SubgroupInvocationID;
        if(index < blockEnd){
            uint k = keys[front].k[index];
            uint curBucket = getMaskedKey(k, uniformInfo[0].pass);
            uint offset = atomicAdd(sharedInfo.keyCount[curBucket], 1);    // adding one to the bucket as an element is inserted
            sharedKeys[offset] = k;
        }
    }
    barrier(); // waiting for all workgroups to assign their keys to the shared key array
    //care: TPB have to be more than there are buckets!!!!
    //if(gl_LocalInvocationID.x < NUMKEYS){
    //    uint offset = 0;
    //    if(gl_LocalInvocationID.x != 0) offset = sharedInfo.keyCount[gl_LocalInvocationID.x - 1];
    //    uint count = sharedInfo.keyCount[gl_LocalInvocationID.x] - offset;
    //    if(count > 0){
    //        uint bucketPos = atomicAdd(uniformInfo[front].globalHistograms[globalHistIndex].keyCount[gl_LocalInvocationID.x], count);
    //        for(int c = 0; c < count; ++c){
    //            keys[back].k[blockStart + bucketPos + c] = sharedKeys[offset + c];
    //        }
    //    }
    //}
    //better implementation: every thread writes KPT konsecutive keys from shared memory to the final list
    uint startIndex = gl_LocalInvocationID.x * KPT;
    uint curBucket = getMaskedKey(sharedKeys[startIndex], uniformInfo[0].pass);
    uint iKeyStart = 0;
    uint bucketCount = 0;
    for(int i = 0; i < KPT && startIndex + i < maxElem;){
        int startInd = i;
        curBucket = getMaskedKey(sharedKeys[startIndex + i++], uniformInfo[0].pass);
        bucketCount = 1;
        while(i < KPT && startIndex + i < maxElem && getMaskedKey(sharedKeys[startIndex + i], uniformInfo[0].pass) == curBucket) {++bucketCount; ++i;}
        uint bucketPos = atomicAdd(uniformInfo[front].globalHistograms[globalHistIndex].keyCount[curBucket], bucketCount);
        for(int j = 0; j < bucketCount; ++j){
            keys[back].k[globalStart + bucketPos + j] = sharedKeys[startIndex + startInd + j];
        }
    }
    //for(int i = 0; i < KPT && startIndex + i < maxElem; ++i){
    //    uint b = getMaskedKey(sharedKeys[startIndex + i], uniformInfo[0].pass);
    //    if(b == curBucket) ++bucketCount;
    //    else{
    //        uint bucketPos = atomicAdd(uniformInfo[front].globalHistograms[globalHistIndex].keyCount[curBucket], bucketCount);
    //        for(int j = 0; j < bucketCount; ++j){
    //            keys[back].k[globalStart + bucketPos + j] = sharedKeys[startIndex + iKeyStart + j];
    //        }
    //        curBucket = b;
    //        bucketCount = 1;
    //        iKeyStart = i;
    //    }
    //}
    //adding the last bucket
    //uint bucketPos = atomicAdd(uniformInfo[front].globalHistograms[globalHistIndex].keyCount[curBucket], bucketCount);
    //for(int j = 0; j < bucketCount; ++j){
    //    keys[back].k[globalStart + bucketPos + j] = sharedKeys[startIndex + iKeyStart + j];
    //}
    //for(int i = 0; i < KPT && startIndex + i < maxElem; ++i){
    //    curBucket = getMaskedKey(sharedKeys[startIndex + i], uniformInfo[0].pass);
    //    uint bucketPos = atomicAdd(uniformInfo[front].globalHistograms[globalHistIndex].keyCount[curBucket], 1);
    //    keys[back].k[globalStart + bucketPos] = sharedKeys[startIndex + i];
    //}
}