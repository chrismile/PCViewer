#version 450
#extension GL_GOOGLE_include_directive: enable

#include "radix_common.glsl"

// Performs counting for each bucket
// Bins are calculated by converting the value to a uint (important for ints and floats)
// and then does the binning
shared uint histogram[local_size * bin_count];
void main(){
    // clear local count
    for(int i = 0; i < bin_count; i++)
        histogram[i * local_size + gl_LocalInvocationID.x] = 0;
    barrier();

    // Figure out this thread group's index into the block data (taking into account thread groups that need to do extra reads)
    uint thread_block_start = (block_size * num_blocks_per_threadgroup * gl_WorkgroupID.x);
    uint NumBlocksToProcess = num_blocks_per_threadgroup;

    if (groupID >= max_number_threadgroups - CBuffer.NumThreadGroupsWithAdditionalBlocks)
    {
        thread_block_start += (groupID - max_number_threadgroups - CBuffer.NumThreadGroupsWithAdditionalBlocks)) * block_size;
        NumBlocksToProcess++;
    }

    // Get the block start index for this thread
    uint BlockIndex = thread_block_start + localID;

    // Count value occurrence
    for (uint BlockCount = 0; BlockCount < NumBlocksToProcess; BlockCount++, BlockIndex += block_size)
    {
        uint DataIndex = BlockIndex;

        // Pre-load the key values in order to hide some of the read latency
        uint srcKeys[FFX_PARALLELSORT_ELEMENTS_PER_THREAD];
        srcKeys[0] = SrcBuffer[DataIndex];
        srcKeys[1] = SrcBuffer[DataIndex + FFX_PARALLELSORT_THREADGROUP_SIZE];
        srcKeys[2] = SrcBuffer[DataIndex + (FFX_PARALLELSORT_THREADGROUP_SIZE * 2)];
        srcKeys[3] = SrcBuffer[DataIndex + (FFX_PARALLELSORT_THREADGROUP_SIZE * 3)];

        for (uint i = 0; i < FFX_PARALLELSORT_ELEMENTS_PER_THREAD; i++)
        {
            if (DataIndex < CBuffer.NumKeys)
            {
                uint localKey = (srcKeys[i] >> ShiftBit) & 0xf;
                InterlockedAdd(gs_FFX_PARALLELSORT_Histogram[(localKey * FFX_PARALLELSORT_THREADGROUP_SIZE) + localID], 1);
                DataIndex += FFX_PARALLELSORT_THREADGROUP_SIZE;
            }
        }
    }

    // Even though our LDS layout guarantees no collisions, our thread group size is greater than a wave
    // so we need to make sure all thread groups are done counting before we start tallying up the results
    GroupMemoryBarrierWithGroupSync();

    if (localID < FFX_PARALLELSORT_SORT_BIN_COUNT)
    {
        uint sum = 0;
        for (int i = 0; i < FFX_PARALLELSORT_THREADGROUP_SIZE; i++)
        {
            sum += gs_FFX_PARALLELSORT_Histogram[localID * FFX_PARALLELSORT_THREADGROUP_SIZE + i];
        }
        SumTable[localID * CBuffer.NumThreadGroups + groupID] = sum;
    }
}