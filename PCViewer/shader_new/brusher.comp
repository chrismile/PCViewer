#version 450
#extension GL_ARB_separate_shader_objects : enable
#extension GL_GOOGLE_include_directive : enable
#extension GL_EXT_scalar_block_layout : enable
#extension GL_EXT_buffer_reference2: require
#extension GL_EXT_buffer_reference_uvec2: require
#extension GL_EXT_shader_explicit_arithmetic_types: enable
#extension GL_EXT_shader_explicit_arithmetic_types_int64 : require
#extension GL_EXT_shader_explicit_arithmetic_types_int8 : require
#extension GL_KHR_shader_subgroup_ballot: enable

layout(buffer_reference, scalar) buffer ActivationBitset{
	uint i[];
};
layout(buffer_reference, scalar) buffer IndexBuffer{
	uint i[];
};
layout(buffer_reference, scalar) buffer Brushes{
    uint range_brush_count;
    uint lasso_brush_count;
    uint lasso_brush_offset;
    uint _;
    float data[];           // for data layout see brush_util.hpp::create_gpu_brush_data(...)
};

layout(push_constant) uniform PCs{
    uint64_t    local_brushes_address;
    uint64_t    global_brushes_address;
    uint64_t    activation_bitset_address;
	uint64_t 	data_header_address;
	uint64_t	index_buffer_address;
	uint		data_size;
    uint        brush_combination;
};

const uint combine_and = 0;
const uint combine_or = 1;
const uint combine_xor = 2;

const uint local_size = 256;
layout(local_size_x = local_size) in;

#include "data_access.glsl"

shared uint act[local_size];
void write_activations(uint iteration, bool a){
    // creating 32 bit words via subgroup ballot. Only works with 32 or 64 bit sized ballots
    uvec4 ballot = subgroupBallot(a);
    if(gl_SubgroupSize == 32){
        if(subgroupElect())
            act[iteration * gl_NumSubgroups + gl_SubgroupID] = ballot[0];
    }
    if(gl_SubgroupSize == 64){
        if(gl_SubgroupInvocationID < 2){
            act[2 * (iteration * gl_NumSubgroups + gl_SubgroupID) + gl_SubgroupInvocationID] = ballot[gl_SubgroupInvocationID];
        }
    }
}

uint check_activations(inout Brushes brushes){
    uint ret = 0;
    
    return ret;
}

// it is guaranteed that if the pipeline is executed there do exist brushes (so check for on brushes is useless)
void main(){
    if(gl_WorkGroupID.x * gl_WorkGroupSize.x * 32 >= data_size)
        return;

    ActivationBitset activation_bitset = ActivationBitset(activation_bitset_address);
    bool identity_index = index_buffer_address == 0;
    IndexBuffer index_buffer;
    if(!identity_index)
        index_buffer = IndexBuffer(index_buffer_address);
    Brushes global_brushes;
    if(brushes_address != 0)
        global_brushes = Brushes(global_brushes_address);
    Brushes local_brushes = Brushes(local_brushes_address);

    uint iteration = 0;
    for(uint i = gl_WorkGroupID.x * gl_WorkGroupSize.x + gl_LocalInvocationID.x; i < data_size && i < (gl_WorkGroupID.x + 1) * gl_WorkGroupSize.x; i += gl_WorkGroupSize.x, ++iteration){
        bool a = brushes.range_brush_count == 0 || brush_combination == combine_and;
        uint index = i;
        if(!identity_index)
            index = index_buffer.i[index];

        // global range brushes
        for(int range_brush = 0; range_brush < brushes.range_brush_count; ++range_brush){
            bool inside = true;
            uint brush_offset = uint(brushes.data[range_brush]);
            for(int axis_map = 0; axis_map < brushes.data[brush_offset]; ++axis_map){
                uint axis_map_offset = uint(brushes.data[brush_offset + 1 + axis_map]);
                uint axis = uint(brushes.data[axis_map_offset + 1]);
                float data = get_packed_data(index, axis);
                bool in_range = false;
                for(int range = 0; range < brushes.data[axis_map_offset]; ++range){
                    float min = brushes.data[axis_map_offset + 2 + 2 * range];
                    float max = brushes.data[axis_map_offset + 2 + 2 * range + 1];
                    if(data >= min && data <= max){
                        in_range = true;
                        break;
                    }
                }
                inside = inside && in_range;
                if(!inside)
                    break;
            }
            if(brush_combination == combine_and && !inside){
                a = false;
                break;
            }
            else if(brush_combination == combine_or && inside){
                a = true;
                break;
            }
        }

        // lasso brushes (TODO)
        write_activations(iteration, a);
    }
    
    for(int i = 0; i < 32; ++i)
        write_activations(iteration, bool((activations >> i) & 1);
    barrier();

    // writeout of activation
    activation_bitset.i[gl_GlobalInvocationID.x] = act[gl_LocalInvocationID.x];
}
